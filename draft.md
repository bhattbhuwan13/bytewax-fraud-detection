# Fraud Detection on Streaming Data
## Introduction
The process of identifying scams and preventing unauthorized users from obtaining money or property through dubious means is known as fraud detection. It is a set of actions performed to identify and thwart fraudsters' attempts to steal money or property. Fraud detection is a common practice in banking, insurance, medical, government, and public sectors.

Money laundering, cyberattacks, false banking claims, faked bank checks, identity theft, etc. are examples of fraudulent activity. Therefore, in order to counteract the rise in fraudulent transactions across various platforms, firms adopt cutting-edge fraud detection and prevention technology.
![](images/fraud.jpg)
Some common use cases of fraud detection are: 

### Financial fraud
The intentional application of unlawful means or activities with the objective to obtain financial gain is calledÂ financial fraud. Some common types of financial fraud are:
- Credit Card Fraud
- Money Laundering

#### Credit Card Fraud
It refers the use of a personal credit card without authorization to carry out fraudulent transactions without that person's awareness. The transaction may be done either by stealing the physical card or by gaining the credit card information by unethical means.

#### Money Laundering
Money laundering refers to the usage of illegaly obtained money to set up a legal business by concealing the source of the money. Once the money is successfully laundered, it becomes exteremy difficult to track down its source.

Fraud detection techniques, either rule based or machine learning powered, can help us flag suspicious transactions and identify potential credit card fraud and money laundering.

### Insurance fraud
Insurance fraud refers to act of successfully claiming benifits from the insurance agency when a person isn't entitled to such gains. Some common examples of insurance fraud are:
- A person providing false information regarding their health condition and underlying diseases to gain a cheaper premium.
- A person/entity increasing the valuation of the property destroyed in order to obtain more money from the insurance agency.
- Unemployment fraud involves a person working on cash or without an official record while simultaneously benifitting from the unemployment insurance. Unemployment fraud can also be comitted by stealing the identity of another unemployed individual.
### Ecommerce fraud
Ecommerce fraud is another common fraud prevalent these days. Ecommerce fraud involves abusing the ecommerce platform or the services provide by the platform. Some example include:
- Posting fake reviews on ecommerce sites with an intention of either harming someone else's reputation or promoting products sold by fraudster himself.
- Falsely claiming the refund for a delivered product while claiming that the product was never delivered.
- Abusing or leaking the promotional code offered by the ecommerce stores

## Fraud Detection on Streaming Data
An undetected fraud can cost money and relationship. For instance, let us assume that you own a credit card provide by bank X. If you misplace the card and a fraudster uses it to purchase expensive items, you lose your money and in turn might opt to end the relationship with the bank for lacking a robust mechanism to detect fraudulent transactions. Hence, it is important to identify such fraud in near real-time. 

Data continuously generated near real time by thousands of sources is called streaming data. For a credit card, this may include data generated by POS terminals, ATMs, ecommerce transactions, etc. Fraud detection on streaming data involves analyzing the real time data to detect any anomalies or outliers.  The anomalies for credit card fraud may include:
- Transactions that originate from an unusual place far away from the user's location
- Transaction having high amount
- Increased velocity of transactions

The next section implements credit card fraud detection for streaming data using [bytewax](https://docs.bytewax.io/apidocs) utilizing pre-configured rules.

## Fraud Detection on Streaming Data with Bytewax
Now that you know the significance of fraud detection system, let us create one using bytewax.

> Bytewax is an open source Python framework for building highly scalable dataflows in a streaming or batch context.

The process involves three steps:  
1. Fake transaction data creation  
2. Rule creation to flag fraudulent transactions  
3. Fraud identification using bytewax  

### Data Creation
For this tutorial, you can either create your own dataset usign the following code snippet or download the final dataset from [here](./mydata.json).  
```python
import random
from datetime import datetime
from random import randrange

import pandas as pd
from faker import Faker

nr_of_customers = 100

fake = Faker()

customers = []

for customers_id in range(nr_of_customers):
    for i in range(7):
        # Create transaction date
        d1 = datetime.strptime(f"1/1/2021 09:15:32", "%m/%d/%Y %H:%M:%S")
        d2 = datetime.strptime(f"1/8/2021 09:15:32", "%m/%d/%Y %H:%M:%S")
        transaction_date = fake.date_between(d1, d2)

        # create amount spent
        amount_spent = fake.pyfloat(
            right_digits=2, positive=True, min_value=1000, max_value=100000
        )

        customers.append([customers_id, transaction_date, amount_spent])

customers_df = pd.DataFrame(
    customers,
    columns=[
        "id",
        "Transaction_time",
        "Amount_spent",
    ],
)

pd.pandas.set_option("display.max_columns", None)
customers_df.to_csv("data.csv", index=False)
```
The above code uses [`Faker`](https://faker.readthedocs.io/en/master/) package to create a dummy dataset for 100 users with 7 transctions each. A sample of generated dataset is shown below:  

| id | Transaction_time | Amount_spent |
|:--:|:----------------:|:------------:|
| 0  | 2021-01-03       | 25805.2      |
| 0  | 2021-01-05       | 70036.98     |
| 1  | 2021-01-05       | 41132.61     |
| 1  | 2021-01-0        | 89545.87     |

After generating the dataset, sort them by id and date and convert it to json using a [converter](https://www.convertcsv.com/csv-to-json.htm). This step is necessary to later process data sequentially for each user.
### Rules for fraud identification
For the sake of convinience, the tutorial defines potential fraudulent transactions as:
1. Transactions whose amount is higher by at least 50% of the immediate previous transaction, and
2. Three or more transactions for a given day/date

For example, if a user spends $1000 on day 1, and $1500 on day 2, since the expenditure on day 2 is higher by 50% than the expenditure on day 1, according to our rules, the transaction for 2 will be flagged as fraudulent. Similarly, if a user makes 3 transactions on the same day, the third and later transactions are flagged as fraudulent.
### Fraud identification using bytewax

Now that you have a sample dataset you can work with, let us create fraud identification using bytewax. 

First, import the following libraries and methods:
- `json`: for reading json data
- `Dataflow`: To create a bytewax dataflow graph
- `run`: To pass the data into the dataflow graph and obtain output
```python
import json
from bytewax import Dataflow, run
```
In order to simulate a streaming data source, create a generator function that returns:
- Epoch number: You can use the "id" from the data as epoch id. 
- Data: The data is a tuple containing a key and a value. In the code below, `id` is key and `Transaction_time` and `Amount_spent` are values.


```python
def load_json(file_name="mydata.json"):
    with open(file_name, "r") as open_file:
        for row in json.load(open_file):
            value = (
                str(row["id"]),
                (
                    row["Transaction_time"],
                    int(row["Amount_spent"]),
                ),
            )

            yield row["id"], value
```
To identify transactions whose amount is higher by at least 50% of the immediate previous transaction, create a function `current_transaction_amount_abnormally_higher` as below:

```python
def current_transaction_amount_abnormally_higher(
    current_amount, previous_amount
):
    return current_amount >= 1.5 * previous_amount
```
Create a class `FraudTransaction` that flags fraudulent transactions using the above rules.

```python
class FraudTransaction:
    def __init__(self):
        self.previous_transaction_value = float("inf")
        self.current_transaction_value = None
        self.flagged_items = []
        self.num_of_one_day_transactions = 1
        self.previous_transaction_date = None

    def detect_fraud(self, data):

        self.current_transaction_value = data[1]

        if current_transaction_amount_abnormally_higher(
            self.current_transaction_value, self.previous_transaction_value
        ):
            self.flagged_items.append(data)
            
        # Finding three or more transactions on the same date
        current_transaction_date = data[0]

        if current_transaction_date == self.previous_transaction_date:
            self.num_of_one_day_transactions += 1
        else:
            self.previous_transaction_date = current_transaction_date
            self.num_of_one_day_transactions = 1

        if self.num_of_one_day_transactions >= 3:
            self.flagged_items.append(data)

        self.previous_transaction_value = self.current_transaction_value
        return self, self.flagged_items

```
The `detect_fraud()` method identifies the fraudulent transactions and stores then in the `flagged_items` list. 

Now, create the flow for the bytewax. The flow consists of steps that are executed sequentially to produce the final output. The final ouput in this case is the standard output containing user id and a corresponding list of flagged transactions. 

```python
flow = Dataflow()

flow.stateful_map(
    "fraud", lambda key: FraudTransaction(), FraudTransaction.detect_fraud
)
flow.reduce_epoch(lambda x, y: y)
flow.capture()


```
Every flow starts with the initialization step `flow = Dataflow()` and ends with `flow.capture()`. The `stateful_map()` is a bytewax function that allows us to perform one-to-one transformation of values in (key, value) pairs while maintaining a persistent state for eacy key when doing the transformation. In this case, the `stateful_map()` function allows us to compare the current transaction date and amount with prior ones. The `stateful_map()` takes two arguments:  
- Builder function: It gets evoked for each new key(in our case the user id). In the above example, the initializer of the `FraudTransaction` class is the builder function.
- Mapper function: It gets invoked for each new data point. In the above example, the `fraud_detect()`method inside the `FraudTransaction` is the mapper function.
Finally, we can run the flow using a for loop.

```python
for epoch, item in run(flow, load_json()):
    print(epoch, item)
```
Upon running the above code, we get user id and a corresponding list containing flagged transactions.

**Sample Output**   

```bash
0 ('0', [('2021-01-03', 93129), ('2021-01-07', 63656)])
1 ('1', [('2021-01-04', 34400), ('2021-01-05', 77828)])
2 ('2', [('2021-01-07', 71674), ('2021-01-07', 80847)])
3 ('3', [])
4 ('4', [('2021-01-04', 99308), ('2021-01-07', 73604), ('2021-01-07', 5190)])
```
